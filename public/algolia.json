[
  {
    "objectID": "fd1cf7e47b29b436043d948841d7fa89ad5c7ce8",
    "permalink": "/post/microservice/go-zero/go-zero_nginx/",
    "title": "Go-Zero 微服务网关：Nginx 统一入口实践","content": "理解 go-zero 中 API 与网关的关系，以及如何使用 Nginx 作为统一流量入口。\nAPI 不是网关 很多人把 go-zero 的 API 服务理解成网关，这其实是个误区。\n如果把单个 API 当网关用，会导致：\n一个 API 对应多个 RPC 改任何业务都要重新构建整个 API 效率低，维护麻烦 正确做法是：API 只是聚合服务，每个业务有自己的 API + RPC：\n用户服务：usercenter-api + usercenter-rpc 订单服务：order-api + order-rpc 支付服务：payment-api + payment-rpc 这样改用户服务只需更新用户相关的代码，互不影响。\n真正的网关 那多个 API 服务怎么统一入口？这才需要真正的网关：\n┌─────────────────┐ │ Nginx │ ← 真正的网关 │ (8888端口) │ └────────┬────────┘ │ ┌────────────────────┼────────────────────┐ │ │ │ ▼ ▼ ▼ ┌───────────────┐ ┌───────────────┐ ┌───────────────┐ │ usercenter-api│ │ order-api │ │ payment-api │ │ :1004 │ │ :1001 │ │ :1002 │ └───────────────┘ └───────────────┘ └───────────────┘ 可选方案：Nginx、Kong、APISIX 等，本质都是统一流量入口。\nNginx 网关配置 server { listen 8081; access_log /var/log/nginx/looklook.com_access.log; error_log /var/log/nginx/looklook.com_error.log; # 订单服务 location /order/ { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://looklook:1001; } # 支付服务 location /payment/ { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://looklook:1002; } # 旅游服务 location /travel/ { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://looklook:1003; } # 用户中心 location /usercenter/ { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://looklook:1004; } } Docker 映射：外部 8888 → 容器内 8081\n请求流程示例 访问 http://127.0.0.1:8888/usercenter/v1/user/detail：\n客户端请求 :8888 ↓ Nginx 匹配 /usercenter/ ↓ 转发到 usercenter-api :1004 ↓ go-zero JWT 鉴权 ↓ 业务逻辑处理 JWT 鉴权 在 API 定义文件中配置需要鉴权的路由：\n// 需要登录的接口 @server( prefix: usercenter/v1 group: user jwt: JwtAuth ) service usercenter { @doc \u0026#34;get user info\u0026#34; @handler detail post /user/detail (UserInfoReq) returns (UserInfoResp) } 在 Logic 中获取用户 ID：\nfunc (l *DetailLogic) Detail(req types.UserInfoReq) (*types.UserInfoResp, error) { // JWT 鉴权通过后，从 ctx 中获取 userId userId := ctxdata.GetUidFromCtx(l.ctx) // ... } 总结 组件 职责 Nginx 统一入口、路由分发、日志收集 API 聚合 RPC、HTTP 协议转换、JWT 鉴权 RPC 内部业务逻辑、服务间通信 这套架构的好处：\n统一入口，便于日志收集和行为分析 各服务独立部署，互不影响 鉴权在 API 层统一处理，RPC 层专注业务 ","date": "2025-12-06 00:00:00",
    "updated": "2025-12-06 00:00:00"
  }, 
  {
    "objectID": "88fe1cb9f3562fd74cf132075ebda14e670aa9a1",
    "permalink": "/post/study/modd%E7%83%AD%E5%8A%A0%E8%BD%BD/",
    "title": "使用 modd 实现 Go 项目热加载","content": "modd 是一个轻量级的文件监听工具，可以在代码变更时自动重新编译并重启服务，提升开发效率。\n安装 modd go install github.com/cortesi/modd/cmd/modd@latest 配置文件 在项目根目录创建 modd.conf：\n# usercenter rpc 服务 app/usercenter/cmd/rpc/**/*.go { prep: go build -o data/server/usercenter-rpc -v app/usercenter/cmd/rpc/usercenter.go daemon +sigkill: ./data/server/usercenter-rpc -f app/usercenter/cmd/rpc/etc/usercenter.yaml } 配置解析 1. 文件监听路径 app/usercenter/cmd/rpc/**/*.go ** 表示递归匹配所有子目录，只要这些 .go 文件有任何改动，就触发本条规则。\n2. prep 指令（准备阶段） prep: go build -o data/server/usercenter-rpc -v app/usercenter/cmd/rpc/usercenter.go 把 usercenter.go 及其依赖编译成二进制文件 -o 指定输出路径 -v 显示详细编译过程，方便排错 3. daemon +sigkill（守护进程） daemon +sigkill: ./data/server/usercenter-rpc -f app/usercenter/cmd/rpc/etc/usercenter.yaml 编译成功后，以守护进程方式启动二进制 -f 指定配置文件路径 +sigkill：文件再次变更时，先用 SIGKILL 强制杀掉旧进程，再重新编译启动 启动热加载 modd 工作流程 代码修改 → modd 检测到变更 → 执行 prep 编译 → 杀掉旧进程 → 启动新进程 多服务配置示例 # usercenter rpc app/usercenter/cmd/rpc/**/*.go { prep: go build -o data/server/usercenter-rpc -v app/usercenter/cmd/rpc/usercenter.go daemon +sigkill: ./data/server/usercenter-rpc -f app/usercenter/cmd/rpc/etc/usercenter.yaml } # order rpc app/order/cmd/rpc/**/*.go { prep: go build -o data/server/order-rpc -v app/order/cmd/rpc/order.go daemon +sigkill: ./data/server/order-rpc -f app/order/cmd/rpc/etc/order.yaml } # api gateway app/gateway/cmd/api/**/*.go { prep: go build -o data/server/gateway-api -v app/gateway/cmd/api/gateway.go daemon +sigkill: ./data/server/gateway-api -f app/gateway/cmd/api/etc/gateway.yaml } 这样每个服务独立监听，改哪个重启哪个，互不影响。\n","date": "2025-12-06 00:00:00",
    "updated": "2025-12-06 00:00:00"
  }, 
  {
    "objectID": "529a9df05fba3e26cc0d5a9ec3dd3c629927134c",
    "permalink": "/post/microservice/go-zero/go-zero%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/",
    "title": "Go-Zero 微服务最佳实践架构","content": "基于 go-zero 的微服务项目目录结构设计，参考 looklook 项目的最佳实践。\n整体架构 app/ ├── usercenter/ # 用户中心服务 │ ├── cmd/ │ │ ├── api/ # HTTP API 接口 │ │ └── rpc/ # gRPC 服务 │ └── model/ # 数据模型 (user, userAuth) │ ├── travel/ # 民宿/旅游服务 │ ├── cmd/ │ │ ├── api/ # HTTP API 接口 │ │ └── rpc/ # gRPC 服务 │ └── model/ # 数据模型 (homestay, business, activity, comment) │ ├── order/ # 订单服务 │ ├── cmd/ │ │ ├── api/ # HTTP API 接口 │ │ ├── rpc/ # gRPC 服务 │ │ └── mq/ # 消息队列消费者 │ └── model/ # 数据模型 (homestayOrder) │ ├── payment/ # 支付服务 │ ├── cmd/ │ │ ├── api/ # HTTP API 接口 │ │ └── rpc/ # gRPC 服务 │ └── model/ # 数据模型 (thirdPayment) │ └── mqueue/ # 消息队列服务 └── cmd/ ├── job/ # 延迟任务处理 (如订单超时取消) └── scheduler/ # 定时任务调度 (如定时统计) 服务内部分层 目录 作用 说明 cmd/api/ HTTP API 接口 对外暴露的 RESTful 接口，供前端/客户端调用 cmd/rpc/ gRPC 服务 内部服务间通信，供其他微服务调用 cmd/mq/ 消息队列消费者 处理异步消息（仅 order 服务有） cmd/job/ 延迟任务处理 消费延迟队列中的任务（仅 mqueue 服务） cmd/scheduler/ 定时任务调度 执行周期性定时任务（仅 mqueue 服务） model/ 数据模型层 数据库表映射、CRUD 操作封装 单个服务详细结构 以 usercenter 为例：\nusercenter/ ├── cmd/ │ ├── api/ │ │ ├── desc/ # API 定 …","date": "2025-12-05 00:00:00",
    "updated": "2025-12-05 00:00:00"
  }, 
  {
    "objectID": "f823d360be438e5af93a7eb6219e83b06c906e24",
    "permalink": "/post/study/study_01/",
    "title": "微服务日志采集链路：从文件到 Kibana","content": "理解微服务架构中日志从产生到可搜索的完整流转过程。\n整体链路 微服务 → 本地日志文件 → Filebeat → Kafka → go-stash → Elasticsearch → Kibana 各环节职责 1. 微服务写日志 各个微服务将日志写入本地文件：\n/var/log/looklook/user.log /var/log/looklook/order.log /var/log/looklook/payment.log ... 为什么不直接发到 ES？\n解耦：服务只管写文件，不关心日志去哪 可靠：即使下游挂了，日志也不丢 2. Filebeat 采集 Filebeat 是轻量级的日志采集器，守着日志文件：\n# filebeat.yml filebeat.inputs: - type: log paths: - /var/log/looklook/*.log output.kafka: hosts: [\u0026#34;kafka:9092\u0026#34;] topic: \u0026#34;looklook-log\u0026#34; 工作方式：\n监听文件变化，有新行立即读取 记录读取位置（offset），重启不重复 批量发送，减少网络开销 3. Kafka 缓冲 Kafka 作为中间缓冲层：\nProducer(Filebeat) → Topic(looklook-log) → Consumer(go-stash) 为什么加这层？\n削峰：日志量突增时不会压垮 ES 解耦：采集和处理可以独立扩展 可靠：消息持久化，消费失败可重试 4. go-stash 处理 go-stash（或 Logstash）从 Kafka 拉取日志，做清洗转换：\n# 典型处理 Input: {\u0026#34;time\u0026#34;:\u0026#34;2025-12-06\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;user login\u0026#34;,\u0026#34;user_id\u0026#34;:123} 处理: - 解析 JSON 字段 - 时间格式转换 - 过滤无用字段 - 添加索引名 Output: 写入 ES 的 looklook-log-2025.12.06 索引 5. Elasticsearch 存储 ES 负责存储和索引，支持全文检索：\n索引: looklook-log-2025.12.06 文档: { time, level, msg, user_id, service, ... } 6. Kibana 查询 最终在 Kibana 上：\n搜索：level:error AND service:order 可视化：错误趋势图、服务调用量 告警：错误数超阈值通知 一图总结 ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌──────────┐ ┌────┐ ┌────────┐ │ 微服务 │───▶│ 日志文件 │───▶│Filebeat │───▶│ Kafka │───▶│Stash│───▶│ ES │ └─────────┘ └─────────┘ └─────────┘ └──────────┘ └────┘ └────────┘ 写入 存储 采集 缓冲 处理 存储/索引 │ ▼ ┌────────┐ │ Kibana │ └────────┘ 查询 这套架构的核心思想：每个组件只做一件事，通过消息队列解耦，任何一环出问题都不会导致日志丢失。\n","date": "2025-12-05 00:00:00",
    "updated": "2025-12-05 00:00:00"
  }, 
  {
    "objectID": "f4d3c62d839106eb24caa105028dee1c82d82690",
    "permalink": "/post/microservice/go-zero/zero_start/",
    "title": "Go-Zero 快速入门指南","content": "Go-Zero 是一个集成了各种工程实践的 Web 和 RPC 框架，本文记录从零开始搭建 Go-Zero 开发环境的完整流程。\n1. 初始化项目 首先创建一个新的 Go 模块：\ngo mod init your-project-name 2. 安装 goctl 工具 goctl 是 go-zero 的代码生成工具，可以通过以下两种方式安装：\n# 方式一：直接安装（推荐） go install github.com/zeromicro/go-zero/tools/goctl@latest # 方式二：作为依赖引入 go get -u github.com/zeromicro/go-zero/tools/goctl 安装完成后验证：\n$ goctl --version goctl version 1.7.3 linux/amd64 3. 安装依赖环境 goctl 提供了一键安装所需依赖的命令：\n$ goctl env check --install --verbose --force 这个命令会检查并安装：\nprotoc：Protocol Buffers 编译器 protoc-gen-go：Go 语言的 protobuf 插件 protoc-gen-go-grpc：gRPC 的 Go 插件 4. 安装 Go-Zero 框架 go get -u github.com/zeromicro/go-zero@latest 5. 常用命令 API 服务生成 根据 .api 文件生成 HTTP 服务代码：\ngoctl api go -api user.api -dir ./user 根据 api 文件生成 Swagger 文档\ngoctl api swagger -api ./api/http/ping.api -dir ./swaggerdoc 参数说明：\n-api：指定 api 定义文件 -dir：指定输出目录 RPC 服务生成 根据 .proto 文件生成 gRPC 服务代码：\ngoctl rpc protoc user.proto --go_out=./types --go-grpc_out=./types --zrpc_out=. Model 生成 根据数据库表生成 CRUD 代码：\n# 从 MySQL 连接生成 goctl model mysql datasource -url=\u0026#34;user:password@tcp(127.0.0.1:3306)/dbname\u0026#34; -table=\u0026#34;user\u0026#34; -dir=\u0026#34;./model\u0026#34; # 从 DDL 文件生成 goctl model mysql ddl -src=\u0026#34;user.sql\u0026#34; -dir=\u0026#34;./model\u0026#34; 6. 项目结构示例 使用 goctl 生成的典型项目结构：\n. ├── etc │ └── user-api.yaml # 配置文件 ├── internal │ ├── config │ │ └── config.go # 配置结构 │ ├── handler # HTTP handlers │ ├── logic # 业务逻辑 │ ├── svc │ │ └── servicecontext.go │ └── types │ └── types.go # 请求/响应结构 ├── user.api # API 定义文件 └── user.go # 入口文件 参考资料 Go-Zero 官方文档 Go-Zero GitHub ","date": "2025-12-04 00:00:00",
    "updated": "2025-12-04 00:00:00"
  }, 
  {
    "objectID": "74528a6fdda3033cf1475eca7368c360f9854773",
    "permalink": "/post/devenv/gvm-install/",
    "title": "GVM 安装与使用指南","content": "GVM (Go Version Manager) 是一个管理多个 Go 版本的工具，方便在不同项目间切换 Go 版本。\n1. 清理旧版本 Go（可选） 如果系统之前使用install安装过 Go，建议先清理干净，避免版本冲突：\nsudo rm -rf /usr/local/go sudo apt-get remove golang sudo apt-get remove golang-go sudo apt-get autoremove 如果是全新环境，可跳过此步骤。\n2. 安装 GVM 安装go版本之前呢 , 有些unbantu版本会需要安装前置的条件\nsudo apt-get install gcc make 执行以下命令安装 GVM：\nbash \u0026lt; \u0026lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer) 安装完成后，重启终端，输入 gvm 验证是否安装成功。\n如果提示命令未找到，需要手动在 ~/.bashrc 底部添加：\n[[ -s \u0026#34;$HOME/.gvm/scripts/gvm\u0026#34; ]] \u0026amp;\u0026amp; source \u0026#34;$HOME/.gvm/scripts/gvm\u0026#34; 然后执行 source ~/.bashrc 使配置生效。\n3. 安装 Go 版本 使用 GVM 安装指定版本的 Go：\n# 方式一：使用预编译二进制（推荐，速度快） gvm install go1.18 -B # 方式二：从源码编译（指定镜像源） gvm install go1.18 --source=https://github.com/golang/go 4. 切换 Go 版本 # 临时切换（仅当前终端生效） gvm use go1.18 # 设为默认版本（每次打开终端自动使用） gvm use go1.18 --default 验证安装：\ngo version go env 常用命令速查 命令 说明 gvm listall 查看所有可安装的版本 gvm list 查看已安装的版本 gvm install go1.x 安装指定版本 gvm use go1.x 切换版本 gvm uninstall go1.x 卸载指定版本 常见问题 GVM 安装后 cd 命令失效 参考 GVM GitHub ","date": "2025-12-04 00:00:00",
    "updated": "2025-12-04 00:00:00"
  }, 
  {
    "objectID": "282ce7cb960016e50e1d9ce9e046088616732090",
    "permalink": "/post/devenv/gvm-cd-bug/",
    "title": "解决 GVM 安装后 cd 命令失效问题","content": "在 Ubuntu 上安装 GVM 后，可能会遇到 cd 命令失效的问题。本文记录问题原因及解决方案。\n问题现象 安装 GVM 后，终端中 cd 命令无法正常工作。\n问题分析 安装 GVM 后，.bashrc 末尾会添加：\n[[ -s \u0026#34;$HOME/.gvm/scripts/gvm\u0026#34; ]] \u0026amp;\u0026amp; source \u0026#34;$HOME/.gvm/scripts/gvm\u0026#34; 这个脚本会加载 gvm-default：\n# ~/.gvm/scripts/gvm export GVM_ROOT=$HOME/.gvm . $GVM_ROOT/scripts/gvm-default 问题出在 gvm-default 脚本的最后一行：\n. \u0026#34;$GVM_ROOT/scripts/env/cd\u0026#34; \u0026amp;\u0026amp; cd . GVM 重写了 cd 命令（用于自动切换 Go 版本），但这会导致系统默认的 cd 命令被覆盖失效。\n解决方案 在 ~/.gvm/scripts/gvm-default 末尾添加 unset cd，取消 GVM 对 cd 的覆盖：\necho \u0026#39;unset cd\u0026#39; \u0026gt;\u0026gt; ~/.gvm/scripts/gvm-default 添加后文件末尾应该是：\n. \u0026#34;$GVM_ROOT/scripts/env/cd\u0026#34; \u0026amp;\u0026amp; cd . unset cd 重新加载配置：\nsource ~/.bashrc 验证修复：\ncd /tmp \u0026amp;\u0026amp; pwd # 输出 /tmp 说明修复成功 总结 GVM 的 cd 覆盖功能本意是在切换目录时自动检测 .go-version 文件并切换 Go 版本，但实现上有 bug。通过 unset cd 可以恢复默认行为，同时不影响 GVM 的其他功能。\n","date": "2025-12-04 00:00:00",
    "updated": "2025-12-04 00:00:00"
  }, 
  {
    "objectID": "02fe9ddc1c8206ac7313718d31be2714fc4f79b5",
    "permalink": "/post/microservice/kitex_hertz/hertz-kitex-quickstart/",
    "title": "Hertz + Kitex 微服务项目搭建指南","content": "使用 Hertz 作为 HTTP 网关 + Kitex 作为 RPC 微服务的项目搭建流程。\n项目结构 . ├── go.mod ├── go.sum └── server ├── cmd │ ├── api # Hertz HTTP 网关 │ └── user # Kitex RPC 服务 ├── idl │ ├── base │ ├── http # Hertz 用的 thrift │ └── rpc # Kitex 用的 thrift └── shared ├── consts └── kitex_gen # 共享的 model 库 环境准备 # 安装 Hertz 脚手架 go install github.com/cloudwego/hertz/cmd/hz@latest # 安装 Kitex 脚手架 go install github.com/cloudwego/kitex/tool/cmd/kitex@latest # 高版本 Go 需要降级 thrift（解决脚手架生成问题） go get github.com/apache/thrift@v0.13.0 Step 1：生成共享 Model 库 在 shared 目录下生成 Kitex model：\ncd server/shared kitex -module haha ./../../idl/rpc/user.thrift 生成后会在 kitex_gen 目录下产生对应的 model 文件。\nStep 2：创建 Kitex RPC 服务 进入 server/cmd/user 目录，指定使用共享的 model 库：\ncd server/cmd/user kitex -service user \\ -module haha \\ -use haha/server/shared/kitex_gen \\ ./../../idl/rpc/user.thrift 生成结构：\nuser/ ├── build.sh ├── handler.go # 在这里编写业务逻辑 ├── kitex_info.yaml ├── main.go └── script/ └── bootstrap.sh 注意：-service 是增量覆盖模式，不会覆盖你修改过的代码。\nStep 3：创建 Hertz HTTP 网关 进入 server/cmd/api 目录：\ncd server/cmd/api hz new -idl ./../../idl/http/user.thrift -module haha/server/cmd/api 生成结构：\napi/ ├── biz/ │ ├── handler/ │ │ ├── ping.go │ │ └── user/ │ │ └── user_service.go # 业务逻辑 │ ├── model/ │ │ ├── base/ │ │ └── user/ │ └── router/ │ ├── register.go │ └── user/ │ ├── middleware.go │ └── user.go ├── main.go ├── router.go ├── router_gen.go └── ... 在 handler 和 router 中编写业务逻辑，然后在当前目录执行服务即可。\n","date": "2025-12-03 00:00:00",
    "updated": "2025-12-03 00:00:00"
  }, 
  {
    "objectID": "45a1b24c940c43fe839922eb2201392c1cd5caa4",
    "permalink": "/post/devenv/wsl2-disk-compact/",
    "title": "WSL2 磁盘空间释放：使用 DiskPart 压缩虚拟磁盘","content": "WSL2 删除文件后磁盘空间不释放？用 DiskPart 压缩虚拟磁盘解决。\n问题 WSL2 中删除文件或清理 Docker 镜像后，虚拟磁盘文件（ext4.vhdx）大小不会自动减少，导致宿主机磁盘空间被持续占用。\n解决步骤 1. 关闭 WSL2 wsl --shutdown 2. 打开 DiskPart 按 Win + R，输入 diskpart，以管理员身份运行。\n3. 找到虚拟磁盘文件 虚拟磁盘文件路径一般在：\nC:\\Users\\你的用户名\\AppData\\Local\\Packages\\ 在该目录下搜索 ext4.vhdx 文件，记下完整路径。\n4. 选择并压缩磁盘 在 DiskPart 中执行：\nselect vdisk file=\u0026#34;C:\\Users\\你的用户名\\AppData\\Local\\Packages\\...\\ext4.vhdx\u0026#34; compact vdisk 等待进度到 100% 完成，关闭窗口即可。\n","date": "2025-12-03 00:00:00",
    "updated": "2025-12-03 00:00:00"
  }, 
  {
    "objectID": "d06f1d318d274aa0fcc8c200429b22b3c9f80eb1",
    "permalink": "/post/golang/rand-pitfalls/",
    "title": "Golang Randder线性同余的坑","content": "记录 Golang math/rand 使用线性同余算法（LCG）带来的问题。\n问题背景 Go 的 math/rand 包默认使用线性同余生成器（Linear Congruential Generator），这会导致几个常见的坑。\n坑 1：默认种子固定，每次运行结果相同 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) func main() { fmt.Println(rand.Intn(100)) // 每次运行都输出 81 fmt.Println(rand.Intn(100)) // 每次运行都输出 87 } 原因：默认种子是 1，不设置种子每次程序启动生成的序列完全一样。\n解决方案：\n// Go 1.20 之前 rand.Seed(time.Now().UnixNano()) // Go 1.20+ 推荐使用 rand.New(rand.NewSource(time.Now().UnixNano())) 坑 2：并发不安全 // 错误示例：多个 goroutine 共享全局 rand for i := 0; i \u0026lt; 10; i++ { go func() { fmt.Println(rand.Intn(100)) // 可能 panic 或产生重复值 }() } 错误的解决方案 1：在 goroutine 内部创建 rand\nfor i := 0; i \u0026lt; 10; i++ { go func() { r := rand.New(rand.NewSource(time.Now().UnixNano())) fmt.Println(r.Intn(100)) }() } 这样写有问题！goroutine 启动太快，time.Now().UnixNano() 可能返回相同的值，导致多个 goroutine 使用相同的种子，生成相同的随机数。\n错误的解决方案 2：循环内创建但加偏移\nfor i := 0; i \u0026lt; 10; i++ { r := rand.New(rand.NewSource(time.Now().UnixNano() + int64(i))) go func(rng *rand.Rand) { fmt.Println(rng.Intn(100)) }(r) } 虽然加了 i 偏移，但循环执行太快时 time.Now().UnixNano() 本身可能没变化，还是会有重复种子的风险。\n正确的解决方案：在外部创建一个 rand，传入 goroutine 使用\n// 方案 1：外部创建单个 rand，通过锁保护（简单场景） var ( rng = rand.New(rand.NewSource(time.Now().UnixNano())) rngMu sync.Mutex ) for i := 0; i \u0026lt; 10; i++ { go func() { rngMu.Lock() n := rng.Intn(100) rngMu.Unlock() fmt.Println(n) }() } // 方案 2：为每个 goroutine 预先创建独立的 rand rngs := make([]*rand.Rand, 10) for i := 0; i \u0026lt; 10; i++ { rngs[i] = rand.New(rand.NewSource(time.Now().UnixNano() + int64(i)*1000)) } for i := 0; i \u0026lt; 10; i++ { go func(r *rand.Rand) { fmt.Println(r.Intn(100)) }(rngs[i]) } // 方案 3：Go 1.20+ 直接用全局 rand（已自动处理并发安全） for i := 0; i \u0026lt; 10; i++ { go func() { fmt.Println(rand.Intn(100)) }() } 坑 3：线性同余可预测，不能用于安全场景 LCG 算法是可预测的，知道几个连续输出就能推算后续值。\n错误用法：\n// 千万别这样生成 token！ token := fmt.Sprintf(\u0026#34;%d\u0026#34;, rand.Int63()) 正确做法：安全场景使用 crypto/rand\nimport \u0026#34;crypto/rand\u0026#34; func generateToken() string { b := make([]byte, 32) crypto_rand.Read(b) return hex.EncodeToString(b) } 坑 4：Go 1.20 的行为变化 Go 1.20 开始，全局 rand 函数自动使用随机种子，不再需要手动 rand.Seed()。但如果你显式调用 rand.Seed()，行为会回退到旧模式。\n// Go 1.20+ 这样写反而有问题 rand.Seed(time.Now().UnixNano()) // 不要这样做了 // 直接用就行 rand.Intn(100) 总结 场景 推荐方案 普通随机数 (Go 1.20+) 直接用 rand.Intn() 普通随机数 (Go 1.20 前) rand.Seed(time.Now().UnixNano()) 并发场景 每个 goroutine 独立 rand.New() 安全场景 (token/密码) crypto/rand ","date": "2025-12-02 00:00:00",
    "updated": "2025-12-02 00:00:00"
  }]