[
  {
    "objectID": "830a141da07b16b33f973ffb7cfc2d68c9191fcc",
    "permalink": "/post/hert_kitex_start/",
    "title": "Hertz + Kitex 微服务项目搭建指南","content": "使用 Hertz 作为 HTTP 网关 + Kitex 作为 RPC 微服务的项目搭建流程。\n项目结构 . ├── go.mod ├── go.sum └── server ├── cmd │ ├── api # Hertz HTTP 网关 │ └── user # Kitex RPC 服务 ├── idl │ ├── base │ ├── http # Hertz 用的 thrift │ └── rpc # Kitex 用的 thrift └── shared ├── consts └── kitex_gen # 共享的 model 库 环境准备 # 安装 Hertz 脚手架 go install github.com/cloudwego/hertz/cmd/hz@latest # 安装 Kitex 脚手架 go install github.com/cloudwego/kitex/tool/cmd/kitex@latest # 高版本 Go 需要降级 thrift（解决脚手架生成问题） go get github.com/apache/thrift@v0.13.0 Step 1：生成共享 Model 库 在 shared 目录下生成 Kitex model：\ncd server/shared kitex -module haha ./../../idl/rpc/user.thrift 生成后会在 kitex_gen 目录下产生对应的 model 文件。\nStep 2：创建 Kitex RPC 服务 进入 server/cmd/user 目录，指定使用共享的 model 库：\ncd server/cmd/user kitex -service user \\ -module haha \\ -use haha/server/shared/kitex_gen \\ ./../../idl/rpc/user.thrift 生成结构：\nuser/ ├── build.sh ├── handler.go # 在这里编写业务逻辑 ├── kitex_info.yaml ├── main.go └── script/ └── bootstrap.sh 注意：-service 是增量覆盖模式，不会覆盖你修改过的代码。\nStep 3：创建 Hertz HTTP 网关 进入 server/cmd/api 目录：\ncd server/cmd/api hz new -idl ./../../idl/http/user.thrift -module haha/server/cmd/api 生成结构：\napi/ ├── biz/ │ ├── handler/ │ │ ├── ping.go │ │ └── user/ │ │ └── user_service.go # 业务逻辑 │ ├── model/ │ │ ├── base/ │ │ └── user/ │ └── router/ │ ├── register.go │ └── user/ │ ├── middleware.go │ └── user.go ├── main.go ├── router.go ├── router_gen.go └── ... 在 handler 和 router 中编写业务逻辑，然后在当前目录执行服务即可。\n","date": "2025-12-03 00:00:00",
    "updated": "2025-12-03 00:00:00"
  }, 
  {
    "objectID": "8a69c004eca324f6d68bca5da8641fad4c5008e0",
    "permalink": "/post/wsl_question/",
    "title": "WSL2 磁盘空间释放：使用 DiskPart 压缩虚拟磁盘","content": "WSL2 删除文件后磁盘空间不释放？用 DiskPart 压缩虚拟磁盘解决。\n问题 WSL2 中删除文件或清理 Docker 镜像后，虚拟磁盘文件（ext4.vhdx）大小不会自动减少，导致宿主机磁盘空间被持续占用。\n解决步骤 1. 关闭 WSL2 wsl --shutdown 2. 打开 DiskPart 按 Win + R，输入 diskpart，以管理员身份运行。\n3. 找到虚拟磁盘文件 虚拟磁盘文件路径一般在：\nC:\\Users\\你的用户名\\AppData\\Local\\Packages\\ 在该目录下搜索 ext4.vhdx 文件，记下完整路径。\n4. 选择并压缩磁盘 在 DiskPart 中执行：\nselect vdisk file=\u0026#34;C:\\Users\\你的用户名\\AppData\\Local\\Packages\\...\\ext4.vhdx\u0026#34; compact vdisk 等待进度到 100% 完成，关闭窗口即可。\n","date": "2025-12-03 00:00:00",
    "updated": "2025-12-03 00:00:00"
  }, 
  {
    "objectID": "866cbdefbea516754767811b2efff6d2d68144d2",
    "permalink": "/post/golang-backend-pitfalls/",
    "title": "Golang Randder线性同余的坑","content": "记录 Golang math/rand 使用线性同余算法（LCG）带来的问题。\n问题背景 Go 的 math/rand 包默认使用线性同余生成器（Linear Congruential Generator），这会导致几个常见的坑。\n坑 1：默认种子固定，每次运行结果相同 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) func main() { fmt.Println(rand.Intn(100)) // 每次运行都输出 81 fmt.Println(rand.Intn(100)) // 每次运行都输出 87 } 原因：默认种子是 1，不设置种子每次程序启动生成的序列完全一样。\n解决方案：\n// Go 1.20 之前 rand.Seed(time.Now().UnixNano()) // Go 1.20+ 推荐使用 rand.New(rand.NewSource(time.Now().UnixNano())) 坑 2：并发不安全 // 错误示例：多个 goroutine 共享全局 rand for i := 0; i \u0026lt; 10; i++ { go func() { fmt.Println(rand.Intn(100)) // 可能 panic 或产生重复值 }() } 错误的解决方案 1：在 goroutine 内部创建 rand\nfor i := 0; i \u0026lt; 10; i++ { go func() { r := rand.New(rand.NewSource(time.Now().UnixNano())) fmt.Println(r.Intn(100)) }() } 这样写有问题！goroutine 启动太快，time.Now().UnixNano() 可能返回相同的值，导致多个 goroutine 使用相同的种子，生成相同的随机数。\n错误的解决方案 2：循环内创建但加偏移\nfor i := 0; i \u0026lt; 10; i++ { r := rand.New(rand.NewSource(time.Now().UnixNano() + int64(i))) go func(rng *rand.Rand) { fmt.Println(rng.Intn(100)) }(r) } 虽然加了 i 偏移，但循环执行太快时 time.Now().UnixNano() 本身可能没变化，还是会有重复种子的风险。\n正确的解决方案：在外部创建一个 rand，传入 goroutine 使用\n// 方案 1：外部创建单个 rand，通过锁保护（简单场景） var ( rng = rand.New(rand.NewSource(time.Now().UnixNano())) rngMu sync.Mutex ) for i := 0; i \u0026lt; 10; i++ { go func() { rngMu.Lock() n := rng.Intn(100) rngMu.Unlock() fmt.Println(n) }() } // 方案 2：为每个 goroutine 预先创建独立的 rand rngs := make([]*rand.Rand, 10) for i := 0; i \u0026lt; 10; i++ { rngs[i] = rand.New(rand.NewSource(time.Now().UnixNano() + int64(i)*1000)) } for i := 0; i \u0026lt; 10; i++ { go func(r *rand.Rand) { fmt.Println(r.Intn(100)) }(rngs[i]) } // 方案 3：Go 1.20+ 直接用全局 rand（已自动处理并发安全） for i := 0; i \u0026lt; 10; i++ { go func() { fmt.Println(rand.Intn(100)) }() } 坑 3：线性同余可预测，不能用于安全场景 LCG 算法是可预测的，知道几个连续输出就能推算后续值。\n错误用法：\n// 千万别这样生成 token！ token := fmt.Sprintf(\u0026#34;%d\u0026#34;, rand.Int63()) 正确做法：安全场景使用 crypto/rand\nimport \u0026#34;crypto/rand\u0026#34; func generateToken() string { b := make([]byte, 32) crypto_rand.Read(b) return hex.EncodeToString(b) } 坑 4：Go 1.20 的行为变化 Go 1.20 开始，全局 rand 函数自动使用随机种子，不再需要手动 rand.Seed()。但如果你显式调用 rand.Seed()，行为会回退到旧模式。\n// Go 1.20+ 这样写反而有问题 rand.Seed(time.Now().UnixNano()) // 不要这样做了 // 直接用就行 rand.Intn(100) 总结 场景 推荐方案 普通随机数 (Go 1.20+) 直接用 rand.Intn() 普通随机数 (Go 1.20 前) rand.Seed(time.Now().UnixNano()) 并发场景 每个 goroutine 独立 rand.New() 安全场景 (token/密码) crypto/rand ","date": "2025-12-02 00:00:00",
    "updated": "2025-12-02 00:00:00"
  }]