[
  {
    "objectID": "74528a6fdda3033cf1475eca7368c360f9854773",
    "permalink": "/post/devenv/gvm-install/",
    "title": "GVM 安装与使用指南","content": "GVM (Go Version Manager) 是一个管理多个 Go 版本的工具，方便在不同项目间切换 Go 版本。\n1. 清理旧版本 Go（可选） 如果系统之前使用install安装过 Go，建议先清理干净，避免版本冲突：\nsudo rm -rf /usr/local/go sudo apt-get remove golang sudo apt-get remove golang-go sudo apt-get autoremove 如果是全新环境，可跳过此步骤。\n2. 安装 GVM 安装go版本之前呢 , 有些unbantu版本会需要安装前置的条件\nsudo apt-get install gcc make 执行以下命令安装 GVM：\nbash \u0026lt; \u0026lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer) 安装完成后，重启终端，输入 gvm 验证是否安装成功。\n如果提示命令未找到，需要手动在 ~/.bashrc 底部添加：\n[[ -s \u0026#34;$HOME/.gvm/scripts/gvm\u0026#34; ]] \u0026amp;\u0026amp; source \u0026#34;$HOME/.gvm/scripts/gvm\u0026#34; 然后执行 source ~/.bashrc 使配置生效。\n3. 安装 Go 版本 使用 GVM 安装指定版本的 Go：\n# 方式一：使用预编译二进制（推荐，速度快） gvm install go1.18 -B # 方式二：从源码编译（指定镜像源） gvm install go1.18 --source=https://github.com/golang/go 4. 切换 Go 版本 # 临时切换（仅当前终端生效） gvm use go1.18 # 设为默认版本（每次打开终端自动使用） gvm use go1.18 --default 验证安装：\ngo version go env 常用命令速查 命令 说明 gvm listall 查看所有可安装的版本 gvm list 查看已安装的版本 gvm install go1.x 安装指定版本 gvm use go1.x 切换版本 gvm uninstall go1.x 卸载指定版本 常见问题 GVM 安装后 cd 命令失效 参考 GVM GitHub ","date": "2025-12-04 00:00:00",
    "updated": "2025-12-04 00:00:00"
  }, 
  {
    "objectID": "282ce7cb960016e50e1d9ce9e046088616732090",
    "permalink": "/post/devenv/gvm-cd-bug/",
    "title": "解决 GVM 安装后 cd 命令失效问题","content": "在 Ubuntu 上安装 GVM 后，可能会遇到 cd 命令失效的问题。本文记录问题原因及解决方案。\n问题现象 安装 GVM 后，终端中 cd 命令无法正常工作。\n问题分析 安装 GVM 后，.bashrc 末尾会添加：\n[[ -s \u0026#34;$HOME/.gvm/scripts/gvm\u0026#34; ]] \u0026amp;\u0026amp; source \u0026#34;$HOME/.gvm/scripts/gvm\u0026#34; 这个脚本会加载 gvm-default：\n# ~/.gvm/scripts/gvm export GVM_ROOT=$HOME/.gvm . $GVM_ROOT/scripts/gvm-default 问题出在 gvm-default 脚本的最后一行：\n. \u0026#34;$GVM_ROOT/scripts/env/cd\u0026#34; \u0026amp;\u0026amp; cd . GVM 重写了 cd 命令（用于自动切换 Go 版本），但这会导致系统默认的 cd 命令被覆盖失效。\n解决方案 在 ~/.gvm/scripts/gvm-default 末尾添加 unset cd，取消 GVM 对 cd 的覆盖：\necho \u0026#39;unset cd\u0026#39; \u0026gt;\u0026gt; ~/.gvm/scripts/gvm-default 添加后文件末尾应该是：\n. \u0026#34;$GVM_ROOT/scripts/env/cd\u0026#34; \u0026amp;\u0026amp; cd . unset cd 重新加载配置：\nsource ~/.bashrc 验证修复：\ncd /tmp \u0026amp;\u0026amp; pwd # 输出 /tmp 说明修复成功 总结 GVM 的 cd 覆盖功能本意是在切换目录时自动检测 .go-version 文件并切换 Go 版本，但实现上有 bug。通过 unset cd 可以恢复默认行为，同时不影响 GVM 的其他功能。\n","date": "2025-12-04 00:00:00",
    "updated": "2025-12-04 00:00:00"
  }, 
  {
    "objectID": "6775a390fe4370620ee203592b465295488afdc3",
    "permalink": "/post/microservice/hertz-kitex-quickstart/",
    "title": "Hertz + Kitex 微服务项目搭建指南","content": "使用 Hertz 作为 HTTP 网关 + Kitex 作为 RPC 微服务的项目搭建流程。\n项目结构 . ├── go.mod ├── go.sum └── server ├── cmd │ ├── api # Hertz HTTP 网关 │ └── user # Kitex RPC 服务 ├── idl │ ├── base │ ├── http # Hertz 用的 thrift │ └── rpc # Kitex 用的 thrift └── shared ├── consts └── kitex_gen # 共享的 model 库 环境准备 # 安装 Hertz 脚手架 go install github.com/cloudwego/hertz/cmd/hz@latest # 安装 Kitex 脚手架 go install github.com/cloudwego/kitex/tool/cmd/kitex@latest # 高版本 Go 需要降级 thrift（解决脚手架生成问题） go get github.com/apache/thrift@v0.13.0 Step 1：生成共享 Model 库 在 shared 目录下生成 Kitex model：\ncd server/shared kitex -module haha ./../../idl/rpc/user.thrift 生成后会在 kitex_gen 目录下产生对应的 model 文件。\nStep 2：创建 Kitex RPC 服务 进入 server/cmd/user 目录，指定使用共享的 model 库：\ncd server/cmd/user kitex -service user \\ -module haha \\ -use haha/server/shared/kitex_gen \\ ./../../idl/rpc/user.thrift 生成结构：\nuser/ ├── build.sh ├── handler.go # 在这里编写业务逻辑 ├── kitex_info.yaml ├── main.go └── script/ └── bootstrap.sh 注意：-service 是增量覆盖模式，不会覆盖你修改过的代码。\nStep 3：创建 Hertz HTTP 网关 进入 server/cmd/api 目录：\ncd server/cmd/api hz new -idl ./../../idl/http/user.thrift -module haha/server/cmd/api 生成结构：\napi/ ├── biz/ │ ├── handler/ │ │ ├── ping.go │ │ └── user/ │ │ └── user_service.go # 业务逻辑 │ ├── model/ │ │ ├── base/ │ │ └── user/ │ └── router/ │ ├── register.go │ └── user/ │ ├── middleware.go │ └── user.go ├── main.go ├── router.go ├── router_gen.go └── ... 在 handler 和 router 中编写业务逻辑，然后在当前目录执行服务即可。\n","date": "2025-12-03 00:00:00",
    "updated": "2025-12-03 00:00:00"
  }, 
  {
    "objectID": "45a1b24c940c43fe839922eb2201392c1cd5caa4",
    "permalink": "/post/devenv/wsl2-disk-compact/",
    "title": "WSL2 磁盘空间释放：使用 DiskPart 压缩虚拟磁盘","content": "WSL2 删除文件后磁盘空间不释放？用 DiskPart 压缩虚拟磁盘解决。\n问题 WSL2 中删除文件或清理 Docker 镜像后，虚拟磁盘文件（ext4.vhdx）大小不会自动减少，导致宿主机磁盘空间被持续占用。\n解决步骤 1. 关闭 WSL2 wsl --shutdown 2. 打开 DiskPart 按 Win + R，输入 diskpart，以管理员身份运行。\n3. 找到虚拟磁盘文件 虚拟磁盘文件路径一般在：\nC:\\Users\\你的用户名\\AppData\\Local\\Packages\\ 在该目录下搜索 ext4.vhdx 文件，记下完整路径。\n4. 选择并压缩磁盘 在 DiskPart 中执行：\nselect vdisk file=\u0026#34;C:\\Users\\你的用户名\\AppData\\Local\\Packages\\...\\ext4.vhdx\u0026#34; compact vdisk 等待进度到 100% 完成，关闭窗口即可。\n","date": "2025-12-03 00:00:00",
    "updated": "2025-12-03 00:00:00"
  }, 
  {
    "objectID": "d06f1d318d274aa0fcc8c200429b22b3c9f80eb1",
    "permalink": "/post/golang/rand-pitfalls/",
    "title": "Golang Randder线性同余的坑","content": "记录 Golang math/rand 使用线性同余算法（LCG）带来的问题。\n问题背景 Go 的 math/rand 包默认使用线性同余生成器（Linear Congruential Generator），这会导致几个常见的坑。\n坑 1：默认种子固定，每次运行结果相同 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) func main() { fmt.Println(rand.Intn(100)) // 每次运行都输出 81 fmt.Println(rand.Intn(100)) // 每次运行都输出 87 } 原因：默认种子是 1，不设置种子每次程序启动生成的序列完全一样。\n解决方案：\n// Go 1.20 之前 rand.Seed(time.Now().UnixNano()) // Go 1.20+ 推荐使用 rand.New(rand.NewSource(time.Now().UnixNano())) 坑 2：并发不安全 // 错误示例：多个 goroutine 共享全局 rand for i := 0; i \u0026lt; 10; i++ { go func() { fmt.Println(rand.Intn(100)) // 可能 panic 或产生重复值 }() } 错误的解决方案 1：在 goroutine 内部创建 rand\nfor i := 0; i \u0026lt; 10; i++ { go func() { r := rand.New(rand.NewSource(time.Now().UnixNano())) fmt.Println(r.Intn(100)) }() } 这样写有问题！goroutine 启动太快，time.Now().UnixNano() 可能返回相同的值，导致多个 goroutine 使用相同的种子，生成相同的随机数。\n错误的解决方案 2：循环内创建但加偏移\nfor i := 0; i \u0026lt; 10; i++ { r := rand.New(rand.NewSource(time.Now().UnixNano() + int64(i))) go func(rng *rand.Rand) { fmt.Println(rng.Intn(100)) }(r) } 虽然加了 i 偏移，但循环执行太快时 time.Now().UnixNano() 本身可能没变化，还是会有重复种子的风险。\n正确的解决方案：在外部创建一个 rand，传入 goroutine 使用\n// 方案 1：外部创建单个 rand，通过锁保护（简单场景） var ( rng = rand.New(rand.NewSource(time.Now().UnixNano())) rngMu sync.Mutex ) for i := 0; i \u0026lt; 10; i++ { go func() { rngMu.Lock() n := rng.Intn(100) rngMu.Unlock() fmt.Println(n) }() } // 方案 2：为每个 goroutine 预先创建独立的 rand rngs := make([]*rand.Rand, 10) for i := 0; i \u0026lt; 10; i++ { rngs[i] = rand.New(rand.NewSource(time.Now().UnixNano() + int64(i)*1000)) } for i := 0; i \u0026lt; 10; i++ { go func(r *rand.Rand) { fmt.Println(r.Intn(100)) }(rngs[i]) } // 方案 3：Go 1.20+ 直接用全局 rand（已自动处理并发安全） for i := 0; i \u0026lt; 10; i++ { go func() { fmt.Println(rand.Intn(100)) }() } 坑 3：线性同余可预测，不能用于安全场景 LCG 算法是可预测的，知道几个连续输出就能推算后续值。\n错误用法：\n// 千万别这样生成 token！ token := fmt.Sprintf(\u0026#34;%d\u0026#34;, rand.Int63()) 正确做法：安全场景使用 crypto/rand\nimport \u0026#34;crypto/rand\u0026#34; func generateToken() string { b := make([]byte, 32) crypto_rand.Read(b) return hex.EncodeToString(b) } 坑 4：Go 1.20 的行为变化 Go 1.20 开始，全局 rand 函数自动使用随机种子，不再需要手动 rand.Seed()。但如果你显式调用 rand.Seed()，行为会回退到旧模式。\n// Go 1.20+ 这样写反而有问题 rand.Seed(time.Now().UnixNano()) // 不要这样做了 // 直接用就行 rand.Intn(100) 总结 场景 推荐方案 普通随机数 (Go 1.20+) 直接用 rand.Intn() 普通随机数 (Go 1.20 前) rand.Seed(time.Now().UnixNano()) 并发场景 每个 goroutine 独立 rand.New() 安全场景 (token/密码) crypto/rand ","date": "2025-12-02 00:00:00",
    "updated": "2025-12-02 00:00:00"
  }]